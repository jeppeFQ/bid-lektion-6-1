---
title: "Softwaredesign"
subtitle: ""
author: "Jeppe Fjeldgaard Qvist"
date: today
format: 
  revealjs:
    #include-after-body: "resources/timer.html"
    navigation-mode: linear
    slide-number: c
    show-slide-number: print
    embed-resources: true
    self-contained-math: true
    smaller: true
    scrollable: true
    theme: default
    include-in-header: 
      - text: |
          <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
          <style>
          .reveal {
            font-family: "Libre Baskerville", serif !important;
          }
          .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
            font-family: "Libre Baskerville", serif !important;
          }
          .reveal .slides section {
            overflow: visible !important;
          }
          .reveal ul, .reveal ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
            overflow: visible !important;
          }
          .reveal li {
            margin-bottom: 0.25em;
            overflow: visible !important;
          }
          </style>
---

## Dagens program

1. Opsamling og opsummering af "Software" (Kap. 4-7 i grundbogen)
2. Ã˜velse med eksempler pÃ¥ eksamensspg. 
3. **Softwaredesign**
4. Gruppearbejde (mini-projekter)

## Opsamling og opsummering af "Software"

1. OS'er: lagring af data, filhÃ¥ndtering
2. Algoritmer
3. Programmer og programmering
4. Python og programmeringsparadigmer 

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}
```{python}
#| eval: false
#| echo: true

class Person:
    def __init__(self, navn: str, alder: int, kÃ¸n: str):
        self.navn = navn
        self.alder = alder   # kalder setter
        self.kÃ¸n = kÃ¸n

    def __str__(self):
        return f"Navn: {self.navn}, Alder: {self.alder}, KÃ¸n: {self.kÃ¸n}"

    @property
    def alder(self) -> int:
        return self._alder

    @alder.setter
    def alder(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise TypeError("Alder skal vÃ¦re et heltal") from None
        if value < 0:
            raise ValueError("Alder kan ikke vÃ¦re negativ")
        self._alder = value
```
:::
:::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.5em;"}
```
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘       BRUGER (DIG)                    â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”***
    â”‚  LAG 5: APPLIKATIONER                       â”‚
    â”‚  Chrome, Word, Spotify, Python scripts      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”****
    â”‚  LAG 4: PROGRAMMERINGSFRAMEWORKS            â”‚
    â”‚  Python, Java, .NET, Node.js                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  LAG 3: SYSTEM BIBLIOTEKER & API'er         â”‚
    â”‚  Windows API, POSIX, DirectX                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”*
    â”‚  LAG 2: OPERATIVSYSTEM (OS)                 â”‚
    â”‚  Windows, macOS, Linux                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  LAG 1: DEVICE DRIVERS                      â”‚
    â”‚  Grafikkort driver, USB driver, etc.        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  LAG 0: FIRMWARE & BIOS/UEFI                â”‚
    â”‚  Boot system, hardware initialisering       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†•
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—**
        â•‘       HARDWARE                        â•‘
        â•‘  CPU, RAM, Harddisk, GPU, etc.        â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```
:::
:::

## Drivers (lag 1)

Eksempler:

::: {style="font-size: 0.7em;"}
* Grafikkort driver (NVIDIA, AMD, Intel)
* Printer driver (HP, Canon, Epson)
* WiFi driver
* USB driver
* Lyd driver
* Mus/tastatur driver
* Hvorfor vigtigt?
:::

Producenten (e.g., Windows, MacOS) laver driver til deres hardware, sÃ¥ vi fx kan bruge vores printer til bÃ¥de vores MacBook sÃ¥vel som ChromeBook. 


## OS 

Operativsystemer (OS) som **Windows**, **Mac** eller **Linux** er computerens "hovedprogram" der styrer alt.

1. NÃ¥r vi klikker med musen eller skriver pÃ¥ tastaturet, oversÃ¦tter OS'et disse kommandoer til noget computeren forstÃ¥r
2. SÃ¸rger for at alle programmer (Python, browser, Word osv.) kan kÃ¸re samtidig uden at kollidere
3. Fordeler computerens ressourcer (hukommelse, processor, harddisk) mellem programmer

Det er med/gennem OS'et vi kan Ã¥bne en terminal/kommandoprompt og kÃ¸re Python-fortolkeren nÃ¥r vi skriver `python3 script.py` og 
OS'en der giver Python adgang til at lÃ¦se/skrive filer pÃ¥ computeren. 


---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.5em;"}

```
1. Process Management (Multitasking)

Chrome     [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 30% CPU
Spotify    [â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 15% CPU
Word       [â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 10% CPU
Python     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 45% CPU
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
              OS fordeler CPU tid
```
:::
:::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.5em;"}

```
2. Memory Management

RAM (16 GB Total):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OS Kernel:        2 GB    â–ˆâ–ˆâ–ˆâ–ˆ              â”‚
â”‚ Chrome:           4 GB    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ          â”‚
â”‚ Python:           1 GB    â–ˆâ–ˆ                â”‚
â”‚ Spotify:          500 MB  â–ˆ                 â”‚
â”‚ Available:        8.5 GB  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
:::
:::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.5em;"}

```
3. File System

Fysisk disk (rÃ¥data):
[01001010|11010010|10101101|...]

           â†“ OS'ens filsystem oversÃ¦tter til
             den logiske struktur vi ser:
C:\
â”œâ”€â”€ Windows\
â”œâ”€â”€ Program Files\
â”œâ”€â”€ Users\
    â””â”€â”€ Anna\
        â””â”€â”€ Documents\
            â””â”€â”€ rapport.docx
```
:::
:::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.5em;"}

```
4. Security & Permissions
 
Fil: secrets.txt

OS tjekker:
âœ“ Er du den rigtige bruger?
âœ“ Har du lÃ¦serettigheder?
âœ“ Har du skriverettigheder?

Hvis nej â†’ "Access Denied" 
```
:::
:::


## OS: Filsystemet

TÃ¦nk pÃ¥ computeren som et arkivskab. Operativsystemet organiserer filer i en **hierarkisk struktur**


::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.2em;"}
```
Computer (Rod)
â”‚
â”œâ”€â”€ Bruger (din profil)
â”‚   â”œâ”€â”€ Dokumenter/
â”‚   â”‚   â”œâ”€â”€ Kurser/
â”‚   â”‚   â”‚   â”œâ”€â”€ Python/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ script.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ data.csv
â”‚   â”‚   â”‚   â””â”€â”€ Ledelse/
â”‚   â”‚   â””â”€â”€ Privat/
â”‚   â”‚
â”‚   â”œâ”€â”€ Downloads/
â”‚   â”œâ”€â”€ Skrivebord/
â”‚   â””â”€â”€ Billeder/
â”‚
â”œâ”€â”€ Program Files/  (installerede programmer)
â””â”€â”€ System/         (OS filer - rÃ¸r dem ikke!)
```
:::
:::

## OS: Navigation

```{bash}
# Windows:
C:\Brugere\Anna\Dokumenter\Python\script.py
```

<br> 

```{bash}
#Mac/Linux:
/Users/Anna/Documents/Python/script.py
```

## OS: Datalagring

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.8em;"}
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CPU REGISTRE (nanosekunders adgang)    â”‚ âš¡âš¡âš¡âš¡âš¡
â”‚  Meget lille: ~KB                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RAM (arbejdshukommelse)                â”‚ âš¡âš¡âš¡âš¡
â”‚  Middel: 8-32 GB                        â”‚
â”‚  FLYGTIGT - slettes ved genstart!       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SSD/HARDDISK (permanent lagring)       â”‚ âš¡âš¡âš¡
â”‚  Stort: 256 GB - 2 TB+                  â”‚
â”‚  PERMANENT - bevares ved genstart       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLOUD/EKSTERN DISK (backup/arkiv)      â”‚ âš¡âš¡
â”‚  Meget stort: ubegrÃ¦nset                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
:::
:::

## OS: Organisering af data

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.2em;"}
```
Anbefalet organisering mini-projekter:
MinProjekt/
â”œâ”€â”€ data/           # RÃ¥ data
â”œâ”€â”€ scripts/        # Python filer
â”œâ”€â”€ output/         # Resultater
â””â”€â”€ README.txt      # Beskrivelse
```
:::
:::

* Brug relative stier i koden 
* LÃ¦g ikke store datafiler i Git/GitHub---brug .gitignore


## Algoritmer 

En algoritme er en prÃ¦cis, trin-for-trin beskrivelse af hvordan man lÃ¸ser et problem eller udfÃ¸rer en opgave. TÃ¦nk pÃ¥ det som en opskrift i kogebogen eller en (skatte)formular: Hvert trin skal vÃ¦re klart defineret og i den rigtige rÃ¦kkefÃ¸lge.

```{bash}
1. Fyld vand i kedel
2. Kog vandet
3. LÃ¦g tepose i kop
4. HÃ¦ld kogende vand i koppen
5. Vent 3-5 minutter
6. Fjern tepose
```

## En god (brugbar) algoritme er eksplicit iht:

* **Input**: Hvad fÃ¥r algoritmen at arbejde med?
* **Output**: Hvad producerer algoritmen?
* **Entydighed**: Hvert trin skal vÃ¦re prÃ¦cist og utvetydigt
* **Endelighed**: Algoritmen skal stoppe efter et endeligt antal trin
* (**Effektivitet**: Algoritmen skal lÃ¸se problemet pÃ¥ en effektiv mÃ¥de)

---

#### SÃ¸gealgoritmer

```{python}
#| eval: false
#| echo: true
# Find alle personer der ikke er elever
ikke_elever = [p for p in personer if not isinstance(p, Elev)]
```

<br>

#### Sorteringsalgoritmer

```{python}
#| eval: false
#| echo: true
# SortÃ©r personer efter alder
sorterede = sorted(personer, key=lambda p: p.alder)
```

---

#### Valideringsalgoritmer

```{python}
#| eval: false
#| echo: true
@alder.setter
def alder(self, value):
    try:
        value = int(value)
    except (TypeError, ValueError):
        raise TypeError("Alder skal vÃ¦re et heltal") from None
    if value < 0:
        raise ValueError("Alder kan ikke vÃ¦re negativ")
    self._alder = value
```

<br>

::: {style="display: flex; justify-content: left; align-items: left;"}
::: {style="font-size: 1em;"}
```
INPUT: value (ukendt datatype)

TRIN:
1. FORSÃ˜G at konvertere value til heltal
2. HVIS konvertering fejler:
   â†’ Kast fejl: "Alder skal vÃ¦re et heltal"
3. HVIS value er negativ:
   â†’ Kast fejl: "Alder kan ikke vÃ¦re negativ"
4. Gem value i _alder

OUTPUT: Valideret alder eller fejlmeddelelse
```
:::
:::

## Programmer og programmering 

Et **program** er en komplet, eksekverbar kodet lÃ¸sning der kombinerer:

1. Algoritmer (problemlÃ¸sning)
2. Datastrukturer (organisering af data)
3. BrugergrÃ¦nseflade (interaktion med brugeren)
4. FejlhÃ¥ndtering (hÃ¥ndtering af uventede situationer)
5. I/O operationer (lÃ¦sning/skrivning af data)

$$
ROGRAM = KODE + DATA + INSTRUKTIONER
$$

Programmet er fx vores fulde `.py`-fil. 

> Hvis en algoritme er en opskrift eller programmet en (robot) kok. 

---

## Programmer vi kender

* Chrome/Firefox - **webbrowser** (`C++`)
* Word/Excel - **tekstbehandling** (`C++/C#`)
* Spotify - **musikafspiller** (`C++/Python/JavaScript`)
* Python i sig selv - **programmeringssprog** (`C)`
* Vores eget script - **script.py** (`Python`)

## `Programmering` er udgjort af:

1. Kodesproget
2. Biblioteket og funktion
3. Adgang til miljÃ¸et programmet kÃ¸rer i

## Kompilerede vs. fortolkede 

:::: {.columns}

::: {.column width="50%"}
```{cpp}
#include <iostream>

int main() {
    int a = 5;
    int b = 10;
    int sum = a + b;
    std::cout << "Sum: " << sum << std::endl;
    return 0;
}
```

<br>
```{bash}
g++ program.cpp -o program.exe    # Kompiler
./program.exe   
```

::: {style="font-size: 0.6em;"}
* Windows: program`.exe`
* Mac: program`.app`
:::

:::

::: {.column width="50%"}
```{python}
#| eval: false
#| echo: true
a = 5
b = 10
sum = a + b
print(f"Sum: {sum}")
```

<br>
```{bash}
python3 script.py    # KÃ¸res direkte uden kompilering!
```

<br>

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kildekode    â”‚         â”‚  Fortolker   â”‚
â”‚              â”‚ â”€â”€â”€â”€â”€â”€> â”‚  (Python)    â”‚
â”‚ script.py    â”‚         â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ lÃ¦ser og
                                â”‚ udfÃ¸rer
                                â”‚ linje for linje
                                â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Computer   â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
:::
:::

:::

::::

---

| Aspekt | C/C++ | Python |
|--------|-------|--------|
| **Hastighed** | Meget hurtig | 10-100x langsommere |
| **Udviklingshastighed** | Langsom | Meget hurtig |
| **SvÃ¦rhedsgrad** | SvÃ¦rt | "Let" |
| **Hukommelsesstyring** | Manuel (vi styrer) | Automatisk (garbage collector) |
| **Typisk anvendelse** | OS, spil, databaser | Scripts, data science, web |
| **Kodelinjer** | Mange | FÃ¥ |

## Compiler/fortolker

* Programmering er blevet mere "demokratisk" efter introduktionen af hÃ¸j-niveau sprog. 

* Niveauerne gÃ¥r fra menneskeligt lÃ¦sbar (hÃ¸j-niveau) til maskinforstÃ¥elig (lav-niveau), hvor hver transformation gÃ¸r koden mere detaljeret men mindre lÃ¦sbar.

Eksempel fra grundbogen: 

$$Z = X + Y$$

1. **GET** values from the memory locations called X and Y **ADD** them togheter and **STORE** them in the memory at location Z
2. "=" is "replace"/"store" ikke "equal to". 

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.7em;"}

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                         HÃ˜J-NIVEAU PYTHON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    def greet(name):
                        message = "Hej " + name
                        return message
                    
                    result = greet("Anna")
                    print(result)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                              â†“ â†“ â†“
                          ğŸ”„ COMPILER
                              â†“ â†“ â†“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        PYTHON BYTECODE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    LOAD_CONST       "Hej "          # Hent tekst "Hej "
    LOAD_FAST        name            # Hent variabel 'name'
    BINARY_ADD                       # LÃ¦g sammen: "Hej " + name
    STORE_FAST       message         # Gem i 'message'
    LOAD_FAST        message         # Hent 'message'
    RETURN_VALUE                     # Returner vÃ¦rdien

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                              â†“ â†“ â†“
                      âš™ï¸  FORTOLKER (PVM)
                              â†“ â†“ â†“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    LAV-NIVEAU MASKINKODE
                    (CPU instruktioner)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    MOV  RAX, [0x7fff...]          # Flyt "Hej " til register
    MOV  RBX, [0x7ffe...]          # Flyt "Anna" til register
    CALL string_concat             # Kald funktion til sammenlÃ¦gning
    MOV  [0x7ffd...], RAX          # Gem resultat i hukommelse
    PUSH RAX                       # Put pÃ¥ stack
    CALL print_function            # Kald print funktion
    POP  RAX                       # Fjern fra stack
    RET                            # Returner

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                              â†“ â†“ â†“
                         ğŸ’» PROCESSOR
                              â†“ â†“ â†“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        BINÃ†R MASKINKODE
                    (0'er og 1'er i hukommelsen)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    10110000 01001000  01100101  01101010    # "Hej "
    10001000 00010101  11110000  00000001    # MOV instruktion
    10110011 01000001  01101110  01101110    # "Anna"
    11101000 00110010  11110000  11111111    # CALL instruktion
    01001000 10001001  00000101  11100000    # MOV resultat
    11110100 00001111  10111000  00000001    # PUSH operation
    ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            OUTPUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                          Hej Anna

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```
:::
:::

---

| Niveau | LÃ¦sbarhed | Hastighed | Eksempel |
|--------|-----------|-----------|----------|
| Python | â­â­â­â­â­ | â­â­â˜†â˜†â˜† | `x = a + b` |
| Bytecode | â­â­â­â˜†â˜† | â­â­â­â˜†â˜† | `BINARY_ADD` |
| Assembly | â­â­â˜†â˜†â˜† | â­â­â­â­â˜† | `ADD RAX, RBX` |
| BinÃ¦r | â­â˜†â˜†â˜†â˜† | â­â­â­â­â­ | `10110000` |

# *Ã˜velse:* FIND ALGORITMERNE!

# Python og programmeringsparadigmer

## Objektorienteret Programmering (OOP)

* Klasser og objekter.
* Attributter og metoder.
* **Indkapsling**: Hold data og metoder sammen i klasser
* **Nedarvning**: Klasser der bygger videre pÃ¥ andre klasser
<br>
* **Polymorfisme** (springes over i dag): Objekter der kan opfÃ¸re sig forskelligt i forskellige situationer
* (**Genbrugelighed**: Skriv kode Ã©n gang, brug den mange gange)
* (**Abstraktion**: Skjul komplekse detaljer bag simple grÃ¦nseflader)
* (**Modularitet**: Opdel store programmer i mindre, hÃ¥ndterbare dele)

## Klasser og Objekter

> TÃ¦nk pÃ¥ en klasse som en kageopskrift og objekter som de fÃ¦rdige kager.

```{python}
#| eval: false
#| echo: true
class Person:
    def __init__(self, navn, alder, kÃ¸n):
        self.navn = navn
        self.alder = alder
        self.kÃ¸n = kÃ¸n
```

* **Klassen** (opskriften) beskriver, hvordan noget skal laves
* **Objektet** (kagen) er det konkrete resultat

---

1. Organiserer data og funktionalitet sammen
2. Modellerer virkeligheden

```{python}
#| eval: false
#| echo: true
# Dette er en klasse (opskriften)
class Kage:
    def __init__(self, smag, stÃ¸rrelse):
        self.smag = smag          # Attribut
        self.stÃ¸rrelse = stÃ¸rrelse # Attribut
    
    def bag(self):                # Metode
        print(f"Bager en {self.stÃ¸rrelse} {self.smag}-kage!")

# Dette er objekter (de fÃ¦rdige kager)
chokoladekage = Kage("chokolade", "stor")
citronkage = Kage("citron", "lille")

# Vi kan bruge metoderne
chokoladekage.bag()  # Output: Bager en stor chokolade-kage!
```

## Attributter og Metoder

* **Attributter** = Egenskaber (hvad objektet HAR)
* **Metoder** = Handlinger (hvad objektet kan GÃ˜RE)

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}

```{python}
#| eval: false
#| echo: true
class Bil:
    # KonstruktÃ¸ren (__init__) kÃ¸rer nÃ¥r vi laver et nyt objekt
    def __init__(self, mÃ¦rke, farve, benzin_tank=50):
        # Attributter (bilens egenskaber)
        self.mÃ¦rke = mÃ¦rke
        self.farve = farve
        self.benzin = benzin_tank
        self.kÃ¸rer = False
        self.kilometer = 0
    
    # Metoder (hvad bilen kan gÃ¸re)
    def start_motor(self):
        if self.benzin > 0:
            self.kÃ¸rer = True
            print(f"{self.mÃ¦rke} er startet! Brummm...")
        else:
            print("Ingen benzin! Tank bilen fÃ¸rst.")
    
    def kÃ¸r(self, distance):
        if not self.kÃ¸rer:
            print("Start motoren fÃ¸rst!")
            return
        
        benzin_forbrug = distance * 0.1  # 0.1 liter per km
        
        if self.benzin >= benzin_forbrug:
            self.benzin -= benzin_forbrug
            self.kilometer += distance
            print(f"KÃ¸rte {distance} km. Benzin tilbage: {self.benzin:.1f} liter")
        else:
            print("Ikke nok benzin til denne tur!")
    
    def tank_op(self, liter):
        self.benzin += liter
        print(f"Tankede {liter} liter. Total benzin: {self.benzin} liter")
    
    def vis_status(self):
        print(f"\n--- {self.mÃ¦rke} Status ---")
        print(f"Farve: {self.farve}")
        print(f"Kilometer kÃ¸rt: {self.kilometer}")
        print(f"Benzin: {self.benzin:.1f} liter")
        print(f"Motor status: {'KÃ¸rer' if self.kÃ¸rer else 'Slukket'}")

# bil-klasse i praksis
min_bil = Bil("Toyota", "rÃ¸d", 30)
din_bil = Bil("Tesla", "blÃ¥", 40)

# Test af forskellige metoder
min_bil.vis_status()
min_bil.start_motor()
min_bil.kÃ¸r(50)
min_bil.tank_op(20)
min_bil.kÃ¸r(100)
min_bil.vis_status()
```
:::
:::

---

## Nedarvning (Inheritance) og indkapsling

* Nedarvning er et hierarkisk forhold mellem klasser, hvor en "barn-klasse" (subklasse) arver egenskaber og metoder fra en "forÃ¦ldre-klasse" (superklasse).
* Nedarvning reprÃ¦senterer et "er-en" forhold. En hund ER ET dyr, en bil ER ET kÃ¸retÃ¸j.

--- 

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}
```{python}
#| eval: false
#| echo: true
class Dyr:  # Superklasse/Basis klasse
    def __init__(self, navn, vÃ¦gt):
        self.navn = navn
        self.vÃ¦gt = vÃ¦gt
        self.levende = True
    
    def spis(self, mad):
        print(f"{self.navn} spiser {mad}")
        self.vÃ¦gt += 0.1
    
    def sov(self):
        print(f"{self.navn} sover...")
    
    def lav_lyd(self):
        # Abstrakt metode: skal overskrives
        raise NotImplementedError("Subklassen skal implementere lav_lyd()")

class Hund(Dyr):  # Subklasse der arver fra Dyr
    def __init__(self, navn, vÃ¦gt, race):
        super().__init__(navn, vÃ¦gt)  # Kalder superklassens konstruktÃ¸r
        self.race = race
    
    def lav_lyd(self):
        return "Vov vov!"
    
    def apporter(self):  # Hund-specifik metode
        print(f"{self.navn} apporterer!")

class Kat(Dyr):
    def __init__(self, navn, vÃ¦gt, pels_farve):
        super().__init__(navn, vÃ¦gt)
        self.pels_farve = pels_farve
    
    def lav_lyd(self):
        return "Miav!"
    
    def kradser(self):  # Kat-specifik metode
        print(f"{self.navn} kradser pÃ¥ mÃ¸blerne!")

# Brug af nedarvning
fido = Hund("Fido", 25, "Golden Retriever")
misser = Kat("Misser", 4, "sort")

# Begge kan bruge Dyr-metoderne
fido.spis("hundemad")
misser.sov()

# Men hver har ogsÃ¥ sine egne specifikke metoder
fido.apporter()
misser.kradser()
```
:::
:::

# *Ã˜velse:* BESKRIV OG DOKUMENTER KODE 

# Softwaredesign 

## FormÃ¥l 

* Organisere din kode sÃ¥ den er nem at forstÃ¥ og vedligeholde
* Genbruge kode i stedet for at gentage dig selv
* Samarbejde bedre med andre programmÃ¸rer
* Finde og rette fejl hurtigere
* Udvide dit program uden at Ã¸delÃ¦gge eksisterende funktionalitet

## Succes-kriterier

* Let at lÃ¦se
* Let at vedligeholde
* Let at udvide
* Let at fejlsÃ¸ge

## DRY (Don't Repeat Yourself)

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
class Elev(Person):
    def __init__(self, navn, alder, kÃ¸n, skole, klassetrin):
        super().__init__(navn, alder, kÃ¸n)  # Genbruger Person's kode
```
<br>
```{python}
#| eval: false
#| echo: true
# DÃ…RLIGT: Gentagen kode
def beregn_lÃ¸n_direktÃ¸r(timer, timelÃ¸n):
    grundlÃ¸n = timer * timelÃ¸n
    bonus = grundlÃ¸n * 0.20
    return grundlÃ¸n + bonus

def beregn_lÃ¸n_manager(timer, timelÃ¸n):
    grundlÃ¸n = timer * timelÃ¸n
    bonus = grundlÃ¸n * 0.15
    return grundlÃ¸n + bonus

# GODT: Genbrugelig funktion
def beregn_lÃ¸n(timer, timelÃ¸n, bonus_procent):
    grundlÃ¸n = timer * timelÃ¸n
    bonus = grundlÃ¸n * bonus_procent
    return grundlÃ¸n + bonus
```
:::
:::


## Separation of Concerns

Hver funktion har Ã©t ansvar!

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.0em;"}
```{python}
#| eval: false
#| echo: true
gem_personer_csv() # Gemmer kun data!
indlaes_personer_csv() # IndlÃ¦ser kun data!
main() - # HÃ¥ndterer kun bruger fladen!
```
:::
:::


## KISS (Keep It Simple, Stupid)

> Hold lÃ¸sninger simple

## YAGNI (You Aren't Gonna Need It)

> Implementer kun det du har brug for nu








<!---
## SOLID Principperne

SOLID er fem designprincipper der hjÃ¦lper med at skabe vedligeholdelsesvenlig og skalerbar kode:

1. **Single Responsibility Principle (SRP): En klasse bÃ¸r kun have Ã©t ansvar og Ã©n grund til at Ã¦ndre sig.**
2. Open/Closed Principle (OCP): Klasser bÃ¸r vÃ¦re Ã¥bne for udvidelse men lukkede for modifikation.
3. Liskov Substitution Principle (LSP): Subklasser skal kunne erstatte deres basis klasser uden at bryde programmets korrekthed.
4. Interface Segregation Principle (ISP): Klienter bÃ¸r ikke tvinges til at afhÃ¦nge af interfaces de ikke bruger.
5. Dependency Inversion Principle (DIP): HÃ¸jniveau moduler bÃ¸r ikke afhÃ¦nge af lavniveau moduler. Begge bÃ¸r afhÃ¦nge af abstraktioner.


--- 

:::: {.columns}

::: {.column width="50%"}
::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}
```{python}
#| eval: false
#| echo: true
# DÃ…RLIGT: Klassen har flere ansvarsomrÃ¥der
class Bruger:
    def __init__(self, navn, email):
        self.navn = navn
        self.email = email
    
    def gem_til_database(self):
        # Database logik her
        pass
    
    def send_email(self):
        # Email logik her
        pass
```
:::
:::
:::

::: {.column width="50%"}
::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.6em;"}
```{python}
#| eval: false
#| echo: true
# GODT: Opdelt i separate klasser med enkelt ansvar
class Bruger:
    def __init__(self, navn, email):
        self.navn = navn
        self.email = email

class BrugerDatabase:
    def gem(self, bruger):
        # Kun database ansvar
        pass

class EmailService:
    def send(self, bruger, besked):
        # Kun email ansvar
        pass
```
:::
:::
:::

::::

---->



## Best Practices Tjekliste

* Er der klar separation of concerns?
* Er koden DRY (ingen duplikering)?
* Er navngivning konsistent og beskrivende?
* Er der passende abstraktion?
* Er koden testbar?
* Er der dokumentation hvor nÃ¸dvendigt?


# Gennemgang af koden fra workshop 1

---


```{python}
#| eval: false
#| echo: true

class Person:
    def __init__(self, navn: str, alder: int, kÃ¸n: str):
        self.navn = navn
        self.alder = alder   # kalder setter
        self.kÃ¸n = kÃ¸n

    def __str__(self):
        return f"Navn: {self.navn}, Alder: {self.alder}, KÃ¸n: {self.kÃ¸n}"

    @property
    def alder(self) -> int:
        return self._alder

    @alder.setter
    def alder(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise TypeError("Alder skal vÃ¦re et heltal") from None
        if value < 0:
            raise ValueError("Alder kan ikke vÃ¦re negativ")
        self._alder = value
```

## `self`

* `self` er ikke et nÃ¸gleord, men en konvention i Python.
* Det er det fÃ¸rste argument i instansmetoder, som refererer til det objekt, metoden bliver kaldt pÃ¥.
* TÃ¦nk pÃ¥ self som â€œdette specifikke objektâ€
* Uden self ved funktionen ikke, hvilket objekt den skal arbejde me


NÃ¥r vi kalder `p.alder()`, oversÃ¦tter Python internt det til:

```{python}
#| eval: false
#| echo: true
Person.alder(p)
```

* `self.navn` = navn â†’ gemmer den konkrete vÃ¦rdi pÃ¥ objektet.
* `self.alder` = alder â†’ kalder alder.setter via property, som igen bruger self._alder.
* `self.kÃ¸n` = kÃ¸n â†’ gemmer kÃ¸n pÃ¥ objektet.

--- 

Uden `self` ville Python ikke vide, hvor attributterne skulle gemmes. De ville vÃ¦re lokale variabler i __init__.

```{python}
#| eval: false
#| echo: true
p = Person("Anna", 25, "F")
Person.__init__(p, "Anna", 25, "F")
# p bliver "self" inde i __init__
```

## Decorators (her, eks. pÃ¥ *validering*)

* Python har indbyggede decorators som `@property`, `@classmethod`, `@staticmethod`.
* En decorator er en slags "pakke" eller "tilfÃ¸jelse", som du kan lÃ¦gge ovenpÃ¥ en funktion eller en klasse, uden at Ã¦ndre selve koden inde i funktionen/klassen.
* `@property` lader os bruge en metode som om den var en attribut og bruges ofte i **klasser**.

```{python}
#| eval: true
#| echo: true
class Cirkel:
    def __init__(self, radius):
        self._radius = radius

    @property
    def areal(self):
        return 3.14 * self._radius**2

c = Cirkel(5)
print(c.areal)  # ser ud som en variabel, men beregnes via en metode
```

---

```{python}
#| eval: true
#| echo: true
class Person:
    def __init__(self, navn, fÃ¸dselsÃ¥r):
        self.navn = navn
        self.fÃ¸dselsÃ¥r = fÃ¸dselsÃ¥r

    @property
    def alder(self):
        from datetime import datetime
        Ã¥r_nu = datetime.now().year
        return Ã¥r_nu - self.fÃ¸dselsÃ¥r

p = Person("Anna", 2000)
print(p.alder)   # ligner en attribut, men beregnes dynamisk
```

---

:::: {.columns}

::: {.column width="50%"}
```{python}
#| eval: false
#| echo: true
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    def get_name(self):
        return self._name
    
    def set_name(self, name):
        self._name = name
    
    def get_age(self):
        return self._age
    
    def set_age(self, age):
        self._age = age

# Brug:
person = Person("Alice", 30)
print(person.get_name())  # "Alice"
person.set_age(31)
print(person.get_age())   # 31
```
:::

::: {.column width="50%"}
```{python}
#| eval: false
#| echo: true
class PersonPythonic:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, name):
        self._name = name
    
    @property
    def age(self):
        return self._age
    
    @age.setter
    def age(self, age):
        self._age = age

# Brug - meget mere naturligt!
person = PersonPythonic("Alice", 30)
print(person.name)  # "Alice" - ser ud som en attribut!
person.age = 31     # Naturlig assignment
print(person.age)   # 31
```
:::

::::

* Vi bruger `@property` til at gÃ¸re alder til en kontrolleret attribut. Udadtil bruger kode person.alder som en almindelig attribut, men internt bliver der kÃ¸rt funktion(er) (en getter og en setter):
* `@property` laver en getter (lÃ¦ser funktion): nÃ¥r du lÃ¦ser p.alder, kaldes denne funktion og returnerer vÃ¦rdien.
* `@alder.setter` binder en setter (skriver funktion): nÃ¥r vi skriver `p.alder = x`, kaldes denne funktion og kan validere/transformere `x` fÃ¸r den gemmes.
* Den konkrete implementering bruger en bagvedliggende variabel `self._alder` til at gemme den faktiske vÃ¦rdi. Hvis ikke, ville det ende i uendelig rekursion.

---

```{python}
#| eval: false
#| echo: true
class Person:
    def __init__(self, navn, alder, kÃ¸n):
        self.navn = navn
        self.alder = alder   # <-- HER kaldes property.setter
        self.kÃ¸n = kÃ¸n

```

* NÃ¥r en Person instantieres, kÃ¸res __init__.
* `self.alder = alder` kalder den metode, som vi har defineret med `@alder.setter`. Setterâ€™en validerer og skriver til `self._alder`.

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 1.2em;"}
```
Kode:   p.alder = 25
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

   p.alder = 25
      â”‚
      â–¼
  1. Python ser at 'alder' er et property-objekt
     (og en data-descriptor, fordi fset findes)
      â”‚
      â–¼
  2. Python kalder property.__set__(obj=p, value=25)
      â”‚
      â–¼
  3. property.__set__ ser at fset er defineret
      â”‚
      â–¼
  4. fset(self, value) kaldes
      â”‚
      â–¼
  5. Din setter-kode kÃ¸rer:
         value = int(value)
         if value < 0: raise ValueError
         self._alder = value

```
:::
:::

<!----

```

   p.alder = 25
      â”‚
      â–¼
1. Python ser at 'alder' er et property-objekt
   â†’ kalder property.__set__(obj=p, value=25)
      â”‚
      â–¼
2. property.__set__ kalder fset(self, value)
      â”‚
      â–¼
3. Din setter kÃ¸rer:
       self.alder = int(value)
      â”‚
      â–¼
4. self.alder = ... er IGEN en tildeling til property 'alder'
   â†’ Python kalder property.__set__(obj=p, value=int(value)) (igen!)
      â”‚
      â–¼
5. property.__set__ kalder fset(self, value) (igen!)
      â”‚
      â–¼
6. Din setter kÃ¸rer igen og forsÃ¸ger self.alder = int(value)
   â†’ ... hvilket kalder property.__set__ igen!
      â”‚
      â–¼
7. Dette gentager sig uendeligt
      â”‚
      â–¼
8. Python nÃ¥r maksimal rekursionsdybde
   â†’ RecursionError: maximum recursion depth exceeded

```

Fordi i setterâ€™en prÃ¸ver vi at sÃ¦tte self.alder (som er propertyâ€™en selv).
â†’ Propertyâ€™en kalder setterâ€™en igen.
â†’ Setterâ€™en prÃ¸ver igen at sÃ¦tte self.alder.
â†’ Loop uden ende.


----->

---

:::: {.columns}

::: {.column width="50%"}
```
p.alder
   â”‚
   â–¼
Person.alder.__get__(p, Person) â† (property.__get__)
   â”‚
   â–¼
fget(self)                      â† (@property metode)
   â”‚
   â–¼
return self._alder
```
:::

::: {.column width="50%"}
```
p.alder = 25
   â”‚
   â–¼
Person.alder.__set__(p, 25) â† (property.__set__)
   â”‚
   â–¼
fset(self, value)           â† (@alder.setter metode)
   â”‚
   â–¼
self._alder = 25
```
:::

::::

---

Hvis vi ikke brugte `@property` og `@alder.setter`, kunne vi lave det samme â€œmanueltâ€ sÃ¥ledes:

:::: {.columns}

::: {.column width="50%"}
```{python}
#| eval: false
#| echo: true
class Person:
    def __init__(self, navn, alder, kÃ¸n):
        self.navn = navn
        self.set_alder(alder)   # vi kalder vores egen setter-metode manuelt
        self.kÃ¸n = kÃ¸n

    def __str__(self):
        return f"Navn: {self.navn}, Alder: {self.get_alder()}, KÃ¸n: {self.kÃ¸n}"

    def get_alder(self) -> int:
        return self._alder

    def set_alder(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise TypeError("Alder skal vÃ¦re et heltal") from None
        if value < 0:
            raise ValueError("Alder kan ikke vÃ¦re negativ")
        self._alder = value

p = Person("Anna", 25, "F")
print(p.get_alder())   # vi SKAL kalde metoden selv
p.set_alder(30)
print(p.get_alder())
```
:::

::: {.column width="50%"}
```{python}
class Person:
    def __init__(self, navn: str, alder: int, kÃ¸n: str):
        self.navn = navn
        self.alder = alder   # kalder setter
        self.kÃ¸n = kÃ¸n

    def __str__(self):
        return f"Navn: {self.navn}, Alder: {self.alder}, KÃ¸n: {self.kÃ¸n}"

    @property
    def alder(self) -> int:
        return self._alder

    @alder.setter
    def alder(self, value):
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise TypeError("Alder skal vÃ¦re et heltal") from None
        if value < 0:
            raise ValueError("Alder kan ikke vÃ¦re negativ")
        self._alder = value
```
:::

::::

---

::: {style="display: flex; justify-content: center; align-items: center;"}
::: {style="font-size: 0.5em;"}
```

                  p = Person("Anna", 25, "F")  <-- instans oprettes
                                â”‚
                                â–¼
                __init__(self=p, navn="Anna", alder=25, kÃ¸n="F")
                                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚                            â”‚
        â–¼                       â–¼                            â–¼
  self.navn = "Anna"      self.alder = 25            self.kÃ¸n = "F"
                            â”‚
                            â–¼
               property.__set__(Person.alder, obj=p, value=25)
                            â”‚
                            â–¼
                 fset(self=p, value=25)  <-- setter-kald
                            â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚                  â”‚
             PrÃ¸v konvertere       TypeError?
             value = int(value)      â”‚
                   â”‚                  â”‚
                   â–¼                  â–¼
               Success              Raise TypeError: "Alder skal vÃ¦re et heltal"
                   â”‚
                   â–¼
            Tjek om value < 0?
                   â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                  â–¼
      False                   True
      â”‚                       â”‚
      â–¼                       â–¼
Gem i instans:           Raise ValueError: "Alder kan ikke vÃ¦re negativ"
self._alder = value

------------------------------------------------------
# LÃ¦se flow (getter):

p.alder  <-- bruger lÃ¦ser property
   â”‚
   â–¼
property.__get__(Person.alder, obj=p, objtype=Person)
   â”‚
   â–¼
fget(self=p)  <-- getter-kald
   â”‚
   â–¼
return self._alder  <-- returnerer den validerede alder
   â”‚
   â–¼
Resultat sendes tilbage til print / kald
```
:::
:::

## MEN VENT: Den Pythoniske Filosofi

> "Start simpelt, refaktorer nÃ¥r nÃ¸dvendigt

```{python}
#| eval: false
#| echo: true
# Start med:
class User:
    def __init__(self, name):
        self.name = name  # Simpel attribut

# DEREFTER udvid med validering:
class User:
    def __init__(self, name):
        self.name = name
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, value):
        if not value.strip():
            raise ValueError("Navn kan ikke vÃ¦re tomt!")
        self._name = value.strip().title()

# Gammel kode virker stadig!
```

# *Mini-projekter!*

